## 컬렉션 프레임워크 - Set

### 자바가 제공하는 Set1 - HashSet, LinkedHashSet
셋은 중복을 허용하지 않고, 순서를 보장하지 않는 자료 구조이다.

#### Collection 인터페이스
`Collection`인터페이스는 `java.util`패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다.
이 인터페이스는 자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드를 정의한다.
`Collection`인터페이스는 `List`, `Set`, `Queue`와 같은 하위 인터페이스와 함께 사용된다.

#### Set 인터페이스
자바의 `Set`인터페이스는 `java.util`패키지의 컬렉션 프레임워크에 속하는 인터페이스 중 하나이다.
`Set`인터페이스는 중복을 허용하지 않는 유일한 요소의 집합을 나타낸다. 즉 어떤 요소도 같은 `Set`내에 두 번 이상 나타날 수 없다.
`Set`은 수학적 집합 개념을 구현한 것으로, 순서를 보장하지 않으며, 특정 요소가 집합에 있는지 여부를 확인하는데 최적화되어 있다.
<br><br>
`Set`인터페이스는 `HashSet`, `LinkedHashSet`, `TreeSet`등의 여러 구현 클래스를 가지고 있으며, 각 클래스는 `Set`인터페이스를 구현하며 각각의 특성을 가지고 있다.

### Set의 주요 구현체

#### 1. HashSet
- **구현**: 해시 자료 구조를 사용해서 요소를 저장한다.
- **순서**: 요소들을 특정한 순서 없이 저장된다. 즉, 요소를 추가한 순서를 보장하지 않는다.
- **시간 복잡도**: `HastSet`의 주요 연산(추가, 삭제, 검색)은 평균적으로 `O(1)`의 시간 복잡도를 가진다.
- **용도**: 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합하다.

#### 2. LinkedHashSet
- **구현**: `LinkedHashSet`은 `HashSet`에 연결 리스트를 추가해서 요소들의 순서를 유지한다.
- **순서**: 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서대로 반환된다.
- **시간 복잡도**: `LinkedHashSet`도 `HashSet`과 마찬가지로 주요 연산에 대해 평균 `O(1)` 시간 복잡도를 가진다.
- **용도**: 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합하다.
- **참고**: 연결 링크를 유지해야 하기 때문에 `HashSet`보다는 조금 더 무겁다.
  - `head(first)`부터 순서대로 링크를 따라가면 입력 순서대로 데이터를 순회할 수 있다. (`tail(last)`도 존재)
  - 양뱡향으로 연결된다.

### 자바가 제공하는 Set2 - TreeSet

#### 3. TreeSet
- **구현**: `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.
- **순서**: 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자(`Comparator`)로 변경할 수 있다.
- **시간 복잡도**: 주요 연산들은 `O(log n)`의 시간 복잡도를 가진다. 따라서 `HashSet`보다는 느리다.
- **용도**: 데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용한다.

#### 트리 구조
`TreeSet`을 이해하려면 트리 구조를 먼저 알아야 한다.

- 트리는 부모 노드와 자식 노드로 구성된다.
- 가장 높은 조상을 루트(root)라 한다. (트리 그림을 뒤집어보면 이해가 갈 것)
- 자식이 2개까지 올 수 있는 트리를 **이진 트리**라 한다.
- 여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손은 더 큰 값을 가지는 것을 **이진 탐색 트리**라 한다.
- `TreeSet`은 이진 탐색 트리를 개선한 레드-블랙 트리를 사용한다.

#### 예시 코드 - 이진 탐색 트리의 노드
```java
class Node {
    Object item;
    Node left;
    Node right;
}
```

#### 이진 탐색 트리의 빅오 - O(log n)
데이터의 개수가 16개의 경우에 단 4번의 비교 연산만으로 최종 노드에 도달할 수 있다.
- 2개의 데이터 => 2로 1번 나누기, `log(2) = 1`
- 4개의 데이터 => 2로 2번 나누기, `log(4) = 2`
- 8개의 데이터 => 2로 3번 나누기, `log(8) = 3`
- 16개의 데이터 => 2로 4번 나누기, `log(16) = 4`
- 32개의 데이터 => 2로 5번 나누기, `log(32) = 5`
- ...
- 1024개의 데이터 => 2로 10번 나누기, `log(1024) = 10`

데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 절반을 날려버리기 때문에, O(n)과 비교해서 데이터 크기가 클수록 효과적이다.
<br>
이것을 수학적으로 `log(n)`으로 표현한다. 빅오 표기법에서는 상수를 사용하지 않으므로 상수를 제외하고 단순히 `O(log n)`로 표현한다.

#### 이진 탐색 트리 개선
- AVL 트리, 레드-블랙 트리 같은 균형을 맞추는 다양한 알고리즘이 존재한다.
- 자바의 `TreeSet`은 레드-블랙 트리를 사용해서 균형을 지속해서 유지한다. 따라서 최악의 경우에도 O(log n)의 성능을 제공한다.

### 자바가 제공하는 Set3 - 예제
- `HastSet`, `LinkedHashSet`, `TreeSet` 모두 `Set`인터페이스를 구현하기 때문에 구현체를 변경하면서 실행할 수 있다.
- `iterator()`를 호출하면 컬렉션을 반복해서 출력할 수 있다.
  - `iterator.hasNext()`: 다음 데이터가 있는지 확인한다.
  - `iterator.next()`: 다음 데이터를 반환한다.

### 자바가 제공하는 Set4 - 최적화
- 자바의 `HashSet`은 데이터의 양이 배열 크기의 75%를 넘어가면 배열의 크기를 2배로 늘리고 2배 늘어난 크기를 기준으로 모든 요소에 해시 인덱스를 다시 적용한다.
  - 이 과정을 `Re-hashing(리-해싱)`이라 한다.

#### 정리
실무에서는 `Set`이 필요한 경우 `HashSet`을 가장 많이 사용한다.
그리고 입력 순서 유지, 값 정렬의 필요에 따라서 `LinkedHashSet`, `TreeSet`을 선택하면 된다.