## 컬렉션 프레임워크 - 해시(Hash)

### 리스트(List) vs 세트(Set)

#### 리스트
- **정의**: 리스트는 요소들의 순차적인 컬렉션이다. 요소들은 특정 순서를 가지며, 같은 요소가 여러 번 나타날 수 있다.
- **특징**:
  - **순서 유지**
  - **중복 허용**
  - **인덱스 접근**
- **용도**: 순서가 중요하거나 중복된 요소를 허용해야 하는 경우에 주로 사용된다.

#### 세트(셋)
- **정의**: 세트(셋)는 유일한 요소들의 컬렉션이다.
- **특징**:
  - **유일성**
  - **순서 미보장**
  - **빠른 검색**: 셋은 요소의 유무를 빠르게 확인할 수 있도록 최적화되어 있다.
- **용도**: 중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용된다.

#### 예시
- **List**: 장바구니 목록, 순서가 중요한 일련의 이벤트 목록
- **Set**: 회원 ID 집합, 고유한 항목의 집합

### 직접 구현하는 Set
- `add(value)`: 셋에 값을 추가한다. 중복 데이터는 저장하지 않는다.
- `contains(value)`: 셋에 값이 있는지 확인한다.
- `remove(value)`: 셋에 있는 값을 제거한다.

#### 예시코드 - 셋 직접 구현하기
```java
import java.util.Arrays;

public class MyHashSetV0 {
    
    private int[] elementData = new int[10];
    private int size = 0;
    
    // O(n)
    public boolean add(int value) {
        if (contains(value)) {
            return false;
        }
        elementData[size] = value;
        size++;
        return true;
    }
    
    // O(n)
    public boolean contains(int value) {
        for (int data : elementData) {
            if (data == value) {
                return true;
            }
        }
        return false;
    }
    
    // getSize()
    // toString()
}
```
- `add()`로 데이터를 추가할 때 셋에 중복 데이터가 있는지 전체 데이터를 항상 확인해야 한다. 따라서 O(n)으로 입력 성능이 나쁘다.
  - 중복 데이터 검색 O(n) + 데이터 입력 O(1) => O(n)
- `contains()`로 데이터를 찾을 때는 배열에 있는 모든 데이터를 찾고 비교해야 하므로 평균 O(n)이 걸린다.

#### 정리
데이터 검색 뿐만 아니라 데이터 추가 또한 O(n)으로 성능이 좋지 않다. 개선이 필요하다.

### 해시 알고리즘1 - 시작
해시(hash) 알고리즘을 사용하면 데이터를 찾는 검색 성능을 평균 O(1)로 비약적으로 끌어올릴 수 있다.

### 해시 알고리즘2 - index 사용
배열은 인덱스의 위치를 사용해서 데이터를 찾을 때 O(1)로 매우 빠른 특징을 가지고 있다.
<br>
**반면에 데이터를 검색할 때는 배열에 들어있는 데이터 하나하나를 모두 비교해야 하므로 인덱스를 활용할 수 없다.**
<br>
만약 데이터를 검색할 때도 인덱스를 활용할 수 있다면, O(n) => O(1)로 성능을 획기적으로 끌어올릴 수 있을 것이다.

#### 개선 방안1
데이터 값 자체를 인덱스로 사용하면 어떨까 ?
<br>
데이터 값을 인덱스 번호로 사용하는 방법으로 O(n)의 검색 연산을 O(1)의 검색 연산으로 바꿀 수 있다.

#### 문제
입력 값의 범위만큼 큰 배열을 사용해야 하므로 **배열에 낭비되는 공간이 많이 발생한다.**

### 해시 알고리즘3 - 나머지 연산
나머지 연산을 사용하면 공간도 절약하면서, 넓은 범위의 값도 사용할 수 있다.
<br>
저장할 수 있는 배열의 크기(**CAPACITY**)를 10이라 가정하면, 그 크기에 맞추어 나머지 연산을 사용하면 된다.

#### 해시 인덱스
배열의 인덱스로 사용할 수 있도록 값을 계산한 인덱스를 해시 인덱스(Hash index)라 한다.

- 저장할 값에 나머지 연산자를 사용해서(해시 코드) 해시 인덱스를 구한다.
  - `1 % 10 = 1`
  - `2 % 10 = 2`
  - `5 % 10 = 5`
  - `8 % 10 = 8`
  - `14 % 10 = 4`
  - `99 % 10 = 9`
- 해시 인덱스를 배열 인덱스로 사용해서 데이터를 저장한다.
  - 예시. `inputArray[hashIndex] = value`
- 배열의 인덱스를 사용하기 때문에 하나의 값을 저장하는데 O(1)로 빠른 성능을 제공한다.

#### 정리
- 입력 값의 범위가 넓어도 실제 데이터 값을 인덱스로 사용하지 않으므로 배열의 크기를 제한하고 메모리 낭비 문제를 해결한다.
- 해시 인덱스를 사용해서 데이터 저장 O(1), 데이터 조회 O(1)의 속도로 성능을 비약적으로 향샹시켰다.

#### 한계 - 해시 충돌
그러나 여전히 한계는 존재한다.
<br>
바로 다른 데이터 값이더라도 같은 해시 인덱스를 가질 수 있다는 점이다. 이를 해시 충돌이라 한다.

### 해시 알고리즘4- 해시 충돌
해시 충돌이 발생했을 때, 적절히 처리하지 않으면 새로 들어온 데이터 값이 기존의 데이터 값을 덮어씌우는 문제가 발생할 수 있다.

#### 해시 충돌 해결방안
해시 충돌을 인정하고, 낮은 확률로 일어날 수 있다고 가정한다.
<br>
해시 충돌이 일어났을 때, 해시 인덱스의 값이 같은 데이터들을 함께 저장해버리는 것이다 !
<br>
**배열 안에 배열을 만들면 된다.** (리스트 같은 다른 자료 구조를 사용해도 된다.)

#### 해시 충돌 - 조회
1. 해시 인덱스로 데이터에 접근한다.
2. 내부에 존재하는 또 다른 리스트에서 `equals()` 또는 `==(기본형)`를 통해, 데이터 값을 비교한다. O(n)

#### 정리
해시 인덱스를 사용하는 방식은 최악의 경우 O(n) 성능을 보인다.
하지만 확률적으로 보면 어느 정도 넓게 퍼지기 때문에 평균으로 보면 대부분 O(1) 성능을 제공한다.

### 해시 인덱스 충돌 확률
해시 충돌이 발생할 확률은 **입력하는 데이터의 수**와 **배열의 크기**와 관련이 있다.
입력하는 데이터의 수와 비교해서 배열의 크기가 클수록 충돌 확률은 낮아진다.
<br>
통계적으로 입력한 데이터의 수가 배열의 크기의 75%를 넘지 않으면 해시 인덱스는 자주 충돌하지 않는다.

#### 정리 - 시간 복잡도
해시 인덱스를 사용하는 경우
- 데이터 저장
  - 평균: O(1)
  - 최악: O(n)
- 데이터 조회
  - 평균: O(1)
  - 최악: O(n)