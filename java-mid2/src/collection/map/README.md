## 컬렉션 프레임워크 - Map, Stack, Queue

### 컬렉션 프레임워크 - Map 소개1
`Map`은 키-값 쌍을 저장하는 자료 구조이다.
- 키는 맵 내에서 유일해야 한다. 그리고 키를 통해 값을 빠르게 검색할 수 있다.
- 키는 중복될 수 없지만, 값은 중복될 수 있다.
- `Map`은 순서를 유지하지 않는다.

자바는 `HashMap`, `LinkedHashMap`, `TreeMap`등 다양한 `Map` 구현체를 제공한다.
이들은 `Map` 인터페이스의 메서드를 구현하며, 각기 다른 특성과 성능 특징을 가지고 있다.

#### 키 목록 조회
`Set<String> keySet = studentMap.keySet()`
<br>
`Map`의 키는 중복을 허용하지 않는다. 따라서 `Map`의 모든 키 목록을 조회하는 `keySet()`을 호출하면, 중복을 허용하지 않는 자료 구조인 `Set`을 반환한다.
<br><br>
`Entry`는 키-값 쌍으로 이루어진 간단한 객체이다.
`Entry`는 `Map` 내부에서 키와 값을 함께 묶어서 저장할 때 사용한다.

#### 값 목록 조회
`Collection<Integer> values = studentMap.values()`
<br>
`Map`의 값 목록은 중복을 허용한다. 따라서 중복을 허용하지 않는 `Set`으로 반환할 수 없다.
그리고 입력 순서를 보장하지 않기 때문에 순서를 보장하는 `List`로 반환하기도 애매하다.
따라서 단순히 값의 모음이라는 의미의 상위 인터페이스인 `Collection`으로 반환한다.

### 컬렉션 프레임워크 - Map 소개2
같은 키로 다른 데이터를 저장하면 어떻게 될까?
<br>
`Map`에 갑을 저장할 때 같은 키에 다른 값을 저장하면 기존 값을 교체한다.
<br>
`Map`에 키가 없는 경우에만 데이터를 저장하고 싶다면, `putIfAbsent()` 메서드를 사용하면 된다.

### 컬렉션 프레임워크 - Map 구현체
`Map`은 인터페이스이기 때문에, 직접 인스턴스를 생성할 수는 없고, 대신 `Map` 인터페이스를 구현한 여러 클래스를 통해 사용할 수 있다.
대표적으로 `HashMap`, `LinkedHashMap`, `TreeMap`이 있다.

#### Map vs Set
`Map`과 `Set`은 거의 같다. 단지 옆에 `value`를 가지고 있는가 없는가의 차이만 있을 뿐이다.
<br>
실제로 자바 `HashSet`의 구현은 대부분 `HashMap`의 구현을 가져다 사용한다. `Map`에서 `value`만 비워두면 `Set`으로 사용할 수 있다.

#### 1. HashMap
- **구조**: `HashMap`은 해시를 사용해서 요소를 저장한다. 키(`Key`)값은 해시 함수를 통해 해시 코드로 변환되고, 이 해시 코드는 데이터를 저장하고 검색하는 데 사용된다.
- **특징**: 삽입, 삭제, 검색 작업은 해시 자료 구조를 사용하므로 일반적으로 상수 시간(`O(1)`)의 시간 복잡도를 가진다.
- **순서**: 순서를 보장하지 않는다.

#### 2. LinkedHashMap
- **구조**: `LinkedHashMap`은 `HashMap`과 유사하지만, 연결 리스트를 사용하여 삽입 순서 또는 최근 접근 순서에 따라 요소를 유지한다.
- **특징**: 입력 순서에 따라 순회가 가능하다. `HashMap`과 같지만 입력 순서를 링크로 유지해야 하므로 `HashMap`보다 조금 더 무겁다.
- **성능**: `HashMap`과 유사하게 대부분의 작업은 `O(1)`의 시간 복잡도를 가진다.
- **순서**: 입력 순서를 보장한다.

#### 3. TreeMap
- **구조**: `TreeMap`은 레드-블랙 트리를 기반으로 한 구현이다.
- **특징**: 모든 키는 자연 순서 또는 생성자에 제공된 `Comparator`에 의해 정렬된다.
- **성능**: `get`, `put`, `remove`와 같은 주요 작업들은 `O(log n)`의 시간 복잡도를 가진다.
- **순서**: 키는 정렬된 순서로 저장된다.

#### 자바 HashMap의 작동 원리
자바의 `HashMap`은 `HashSet`과 작동 원리가 같다.
- `Entry`를 사용해서 `Key`와 `Value`를 하나로 묶어서 저장한다.

이렇게 해시를 사용해서 키와 값을 저장하는 자료 구조를 일반적으로 해시 테이블이라 한다.

#### 정리
실무에서는 `Map`이 필요한 경우 `HashMap`을 많이 사용한다. 그리고 순서 유지, 정렬의 필요에 따라서 `LinkedHashMap`, `TreeMap`을 선택하면 된다.

### 스택 자료 구조

#### 후입 선출(LIFO, Last In First Out)
나중에 넣은 것이 가장 먼저 나오는 것을 후입 선출이라 하고, 이런 자료 구조를 스택이라 한다.
<br><br>
전통적으로 스택에 값을 넣는 것을 `push`라 하고, 스택에서 값을 꺼내는 것을 `pop`이라 한다.

#### 주의 - Stack 클래스는 사용하지 말자
`Vector`를 사용하는 `Stack` 클래스를 사용하지 않는 것을 권장한다. 대신에 `Deque`를 사용하는 것이 좋다.

### 큐 자료 구조

#### 선입 선출(FIFO, First In First Out)
가장 먼저 넣은 것이 가장 먼저 나오는 것을 선입 선출이라 한다. 이런 자료 구조를 큐(Queue)라 한다.
<br><br>
전통적으로 큐에 값을 넣는 것을 `offer`라 하고, 값을 꺼내는 것을 `poll`이라 한다.

#### 컬렉션 프레임워크 - Queue
- `Queue` 인터페이스는 `List`, `Set`과 같이 `Collection`의 자식이다. (인터페이스끼리는 부모와 자식이라 부른다.)
- `Queue`의 대표적인 구현체는 `ArrayDeque`와 `LinkedList`가 있다.
  - `LinkedList`는 `Deque`와 `List` 인터페이스를 모두 구현한다.

### Deque 자료 구조
`Deque`는 "Double Ended Queue"의 약자로, 양쪽 끝에서 요소를 추가하거나 제거할 수 있다.
<br>
Deque는 일반적인 큐(Queue)와 스택(Stack)의 기능을 모두 포함하고 있어, 매우 유연한 자료 구조이다.

#### Deque 구현체와 성능 테스트
`Deque`의 대표적인 구현체는 `ArrayDeque`와 `LinkedList`가 있다. 둘 중 `ArrayDeque`가 모든 면에서 더 빠르다.
<br>
둘의 차이는 `ArrayList`와 `LinkedList`의 차이와 비슷한데, 하나는 배열을 하나는 동적 노드 링크를 사용하기 때문이다.
<br>
`ArrayDeque`는 추가로 원형 큐 자료 구조를 사용하기 때문에 앞, 뒤 입력 모두 O(1)의 성능을 제공한다.
 
#### 정리
`Deque` 인터페이스는 `Queue` 인터페이스의 자식이기 때문에, 단순히 `Queue`의 기능만 필요하면 `Qeuee의 인터페이스를 사용하고, 더 많은 기능이 필요하면 `Deque` 인터페이스를 사요하면 된다.
그리고 구현체로 성능이 빠른 `ArrayDeque`를 사용하자.