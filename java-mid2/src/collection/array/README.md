## 컬렉션 프레임워크 - ArrayList

### 배열의 특징1 - 배열과 인덱스
배열과 같이 여러 데이터(자료)를 구조화해서 다루는 것을 자료 구조라 한다.
<br>
자바는 배열 뿐만 아니라, 컬렉션 프레임워크라는 이름으로 다양한 자료 구조를 제공한다.

#### 배열의 특징
- 배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.
- 인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다.

#### 배열의 검색
배열에 들어있는 데이터를 찾는 것을 검색이라 한다.
<br>
배열의 순차 검색은 배열에 들어있는 데이터의 크기만큼 연산이 필요하다.
**배열의 크기가 n이면 연산도 n만큼 필요하다.**

### 빅오(O) 표기법
빅오(Big O) 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다.
이는 특히 알고리즘이 처리해야할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.
여기서 중요한 것은 알고리즘의 정확한 실행 시간을 계산하는 것이 아니라, 데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이다.

#### 빅오 표기법의 예시
- **O(1)** - 상수 시간: 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정하다.
  - 예시. 배열에서 인덱스를 사용하는 경우
- **O(n)** - 선형 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
  - 예시. 배열의 검색, 배열의 모든 요소를 순회하는 경우
- **O(n^2)** - 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
  - 예시. 보통 이중 반복문을 사용하는 알고리즘에서 나타난다.
- **O(log n)** - 로그 시간: 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
  - 예시. 이진 탐색
- **O(n log n)** - 선형 로그 시간
  - 예시. 많은 효율적인 정렬 알고리즘들

#### 참고
빅오 표기법은 정확한 성능을 측정하는 것이 목표가 아니라 매우 큰 데이터가 들어왔을 때의 대략적인 추세를 비교하는 것이 목적이다.
따라서 데이터가 매우 많이 들어오면 추세를 보는데 상수는 크게 의미가 없어진다.
<br>
이런 이유로 빅오 표기법에서는 상수를 제거한다.
<br>
빅오 표기법은 별도의 이야기가 없으면 보통 최악의 상황을 가정해서 표기한다.

#### 배열 정리
- 배열의 인덱스 사용: O(1)
- 배열의 순차 검색: O(n)

### 배열의 특징2 - 데이터 추가

#### 배열에 데이터를 추가할 때 위치에 따른 성능 변화
- 배열의 첫 번째 위치에 추가
  - 배열의 첫 번째 위치를 찾는데는 인덱스를 사용하므로 O(1)이 걸린다.
  - 모든 데이터를 배열의 크기만큼 한 칸씩 이동해야 한다. 따라서 O(n)만큼의 연산이 걸린다.
  - O(1 + n) => O(n)
- 배열이 중간 위치에 추가
  - 배열의 위치를 찾는데는 O(1)이 걸린다.
  - index의 오른쪽에 있는 데이터를 모두 한 칸씩 이동해야 한다. 따라서 평균 연산은 O(n/2)이 된다.
  - O(1 + n/2) => O(n)
- 배열의 마지막 위치에 추가
  - 배열의 길이를 사용하면 마지막 인덱스에 바로 접근할 수 있고, 기존 배열을 이동하지 않으므로
  - O(1)

#### 배열의 한계
배열은 가장 기본적인 자료 구조이고, 특히 인덱스를 사용할 때 최고의 효율이 나온다. 하지만 이런 배열은 배열의 크기를 생성하는 시점에 미리 정해야 한다는 큰 단점이 있다.
<br>
너무 **작은 크기의 배열**을 생성하면, 데이터를 다 넣을 수 없는 문제가,
너무 **큰 크기의 배열**을 생성하면, 메모리가 낭비된다는 문제가 발생할 수 있다.
<br>
또한 앞이나 중간에 데이털르 추가하기 불편하다. 배열의 이런 불편함을 해소하고 동적으로 데이터를 추가할 수 있는 자료 구조를 List(리스트)라 한다.
<br><br>
일반적으로 배열과 리스트는 구분해서 이야기한다. 리스트는 배열보다 유연한 자료 구조로, 크기가 동적으로 변할 수 있다.
- **배열**: 순서가 있고 중복을 허용하지만 크기가 정적으로 고정된다.
- **리스트**: 순서가 있고 중복을 허용하지만 크기가 동적으로 변할 수 있다.

### 직접 구현하는 배열 리스트
- **동적 배열 기능**: `size` == `capacity`이면, capacity * 2만큼의 배열을 생성해 데이터를 복사한 뒤 새로 참조한다.
- **데이터 삭제 기능**: 해당 index의 데이터를 삭제하고, 삭제할 데이터의 위치를 기준으로 데이터를 한 칸씩 왼쪽으로 이동한다.
  - 삭제된 데이터를 반환한다.
- **제네릭**: 코드 재사용성과 타입 안전성이 높은 자료구조를 만들 수 있다.

#### Object 배열을 사용한 이유
`Object[] elementData`을 그대로 사용하는 이유
- 제네릭은 런타임에 이레이저에 의해 타입 정보가 사라진다. 따라서 런타임에 타입 정보가 필요한 생성자에 사용할 수 없다. 따라서 제네릭을 기반으로 배열을 생성하는 다음 코드는 작동하지 않고, 컴파일 오류가 발생한다.
  - `new E[DEFAULT_CAPACITY]`
- 대신에 다음과 같이 모든 데이터를 담을 수 있는 `Object`를 그대로 사용해야 한다.
  - `new Object[DEFAULT_CAPACIT]`
